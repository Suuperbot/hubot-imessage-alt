// Generated by CoffeeScript 1.10.0
(function () {
    var Adapter, AppleScript, Message, Response, Robot, TextMessage, User, iMessageAdapter, path, ref,
        extend = function (child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }

            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        },
        hasProp = {}.hasOwnProperty,
        slice = [].slice,
        indexOf = [].indexOf || function (item) {
                for (var i = 0, l = this.length; i < l; i++) {
                    if (i in this && this[i] === item) return i;
                }
                return -1;
            };

    ref = require('hubot'), User = ref.User, Robot = ref.Robot, Adapter = ref.Adapter, Message = ref.Message, TextMessage = ref.TextMessage, Response = ref.Response;

    AppleScript = require('applescript');

    path = require('path');
    var sqlite3 = require('sqlite3').verbose();

    var fs = require("fs");
    var dir = process.env.HOME + '/Library/Messages/';
    var file = process.env.HOME + '/Library/Messages/chat.db';
    var child_process = require('child_process');

    var main_chat_title = '';

    var exists = fs.existsSync(file);
    if (!exists) {
        return;
    }

    // discover if we are running and old version of OS X or not
    var OLD_OSX = false;
    var os = require('os');
    if (os.release().split('.')[0] === "12") { // 12 is 10.8 Mountain Lion, which does not have named group chats
        OLD_OSX = true;
    }

    // discover whether the keyboard setting "Full Keyboard Access" is set to
    // "Text boxes and lists only" -- error or 1 or less
    // "All controls" (takes 2 tabs instead of one switching between elements in Messages.app) -- 2 or more
    var FULL_KEYBOARD_ACCESS = false; // false for text boxes and lists, true for all controls

    child_process.exec('defaults read NSGlobalDomain AppleKeyboardUIMode', function (err, stdout, stderr) {
        if (err instanceof Error) {
            // return because we already have false set and error means text boxes and lists only
            return;
        }

        if (parseInt(stdout) > 1) {
            FULL_KEYBOARD_ACCESS = true;
        }
    });

    // read the Messages.app sqlite db
    var db = new sqlite3.Database(file);

    // internally used variables
    var LAST_SEEN_ID = 0;
    var ENABLE_OTHER_SERVICES = false;
    var sending = false;


    iMessageAdapter = (function (superClass) {
        extend(iMessageAdapter, superClass);

        function iMessageAdapter(robot) {
            this.robot = robot;
        }

        iMessageAdapter.prototype.checkMessageText = function(messageId) {
            var SQL = "SELECT DISTINCT message.ROWID, handle.id, message.text, message.is_from_me, message.date, message.date_delivered, message.date_read, chat.chat_identifier, chat.display_name FROM message LEFT OUTER JOIN chat ON chat.room_name = message.cache_roomnames LEFT OUTER JOIN handle ON handle.ROWID = message.handle_id WHERE message.service = 'iMessage' AND message.ROWID = " + messageId + " ORDER BY message.date DESC LIMIT 500";
            if (OLD_OSX) {
                SQL = "SELECT DISTINCT message.ROWID, handle.id, message.text, message.is_from_me, message.date, message.date_delivered, message.date_read FROM message LEFT OUTER JOIN chat LEFT OUTER JOIN handle ON handle.ROWID = message.handle_id WHERE message.service = 'iMessage' AND message.ROWID = " + messageId + " ORDER BY message.date DESC LIMIT 500";
            }
            var imAdapter = this;

            db.serialize(function () {
                var arr = [];
                db.all(SQL, function (err, rows) {
                    if (err) throw err;
                    // should only be one result since we are selecting by id but I am looping anyways
                    for (var i = 0; i < rows.length; i++) {
                        var row = rows[i];
                        console.log(row);
                        if (row.is_from_me || !row || !row.text) {
                            return;
                        }

                        var chatter;
                        var isGroupChat = false;
                        if (row.chat_identifier === null) {
                            chatter = row.id;
                        } else if (arr.indexOf(row.chat_identifier) < 0 && arr.indexOf(row.display_name + '-' + row.chat_identifier) < 0) {
                            if (row.chat_identifier.indexOf('chat') > -1) {
                                if (row.display_name && row.display_name !== "" && typeof(row.display_name) !== "undefined" || OLD_OSX) {
                                    chatter = row.display_name;
                                    isGroupChat = true;
                                }
                            } else {
                                if (row.chat_identifier && row.chat_identifier !== "" && typeof(row.chat_identifier) !== "undefined") {
                                    chatter = row.chat_identifier;
                                    isGroupChat = true;
                                }
                            }
                        }

                        var message = row.text;

                        console.log("message: ", message);
                        console.log("iMessage user: ", chatter);

                        imAdapter.receive(new TextMessage(chatter, message));

                        //if (rowText.split(' ', 1)[0] === '.i') {
                        //    sendiMessage(rowText, chatter, isGroupChat);
                        //} else if (rowText.split(' ', 1)[0] === '.r') {
                                // used to clear applescript errors
                        //    applescript.execFile(__dirname + '/applescripts/send_return.AppleScript', [], function(err, result) {});
                        //}
                    }
                });
            });
        }

        iMessageAdapter.prototype.send = function () {
            console.log("iMessageAdapter.send");
            var envelope, i, len, message, results, script, strings, user;
            envelope = arguments[0], strings = 2 <= arguments.length ? slice.call(arguments, 1) : [];
            user = envelope.user.id;
            console.log(user);

            script = path.resolve(__dirname, 'Send iMessage.applescript');
            results = [];
            for (i = 0, len = strings.length; i < len; i++) {
                message = strings[i];
                console.log(message);
            }

            //if (indexOf.call(this.allowedUsers, user) >= 0) {
            //    script = path.resolve(__dirname, 'Send iMessage.applescript');
            //    results = [];
            //    for (i = 0, len = strings.length; i < len; i++) {
            //        message = strings[i];
            //        results.push(AppleScript.execFile(script, [user, message], function (err, rtn) {
            //            return console.log("send - ", user, message);
            //        }));
            //    }
            //    return results;
            //} else {
            //    return this.robot.logger.info('Refusing to send message to unauthorized iMessage user ' + user);
            //}
        };

        iMessageAdapter.prototype.reply = function () {
            console.log("iMessageAdapter.reply");
            var envelope, strings;
            envelope = arguments[0], strings = 2 <= arguments.length ? slice.call(arguments, 1) : [];
            return this.send.apply(this, [envelope].concat(slice.call(strings)));
        };

        // Use setInterval to continually check iMessage for new messages every 3 seconds
        iMessageAdapter.prototype.run = function () {
            var imAdapter = this;

            // Set the Last Seen ID
            db.serialize(function () {
                db.all("SELECT MAX(ROWID) AS max FROM message", function (err, rows) {
                    if (rows) {
                        var max = rows[0].max;
                        if (max > LAST_SEEN_ID) {
                            LAST_SEEN_ID = max;
                            return;
                        }
                    }
                }.bind(this));
            }.bind(this));

            setInterval(function () {
                db.serialize(function () {
                    db.all("SELECT MAX(ROWID) AS max FROM message", function (err, rows) {
                        if (rows && !sending) {
                            var max = rows[0].max;
                            if (max > LAST_SEEN_ID) {
                                for (LAST_SEEN_ID; LAST_SEEN_ID <= max; LAST_SEEN_ID++) {
                                    imAdapter.checkMessageText(LAST_SEEN_ID);
                                }
                            }
                        }
                    }.bind(this));
                }.bind(this));
            }, 3000);

            return this.emit('connected');
        };

        return iMessageAdapter;

    })(Adapter);

    exports.use = function (robot) {
        return new iMessageAdapter(robot);
    };

}).call(this);

//# sourceMappingURL=imessage.js.map

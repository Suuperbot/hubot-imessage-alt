// Generated by CoffeeScript 1.10.0, which is why some of the JS looks weird
(function () {
    var Adapter, AppleScript, Message, Response, Robot, TextMessage, User, iMessageAdapter, path, ref,
        extend = function (child, parent) {
            for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }

            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        },
        hasProp = {}.hasOwnProperty,
        slice = [].slice,
        indexOf = [].indexOf || function (item) {
                for (var i = 0, l = this.length; i < l; i++) {
                    if (i in this && this[i] === item) return i;
                }
                return -1;
            };

    ref = require('hubot'), User = ref.User, Robot = ref.Robot, Adapter = ref.Adapter, Message = ref.Message, TextMessage = ref.TextMessage, Response = ref.Response;

    AppleScript = require('applescript');
    var imessagemodule = require('iMessageModule');
    path = require('path');
    var sqlite3 = require('sqlite3').verbose();

    var fs = require("fs");
    var dir = process.env.HOME + '/Library/Messages/';
    var file = process.env.HOME + '/Library/Messages/chat.db';
    var child_process = require('child_process');

    var main_chat_title = '';

    var exists = fs.existsSync(file);
    if (!exists) {
        return;
    }

    // discover if we are running and old version of OS X or not
    var OLD_OSX = false;
    var os = require('os');
    if (os.release().split('.')[0] === "12") { // 12 is 10.8 Mountain Lion, which does not have named group chats
        OLD_OSX = true;
    }

    console.log("os: ", os.release());

    // discover whether the keyboard setting "Full Keyboard Access" is set to
    // "Text boxes and lists only" -- error or 1 or less
    // "All controls" (takes 2 tabs instead of one switching between elements in Messages.app) -- 2 or more
    var FULL_KEYBOARD_ACCESS = false; // false for text boxes and lists, true for all controls

    //

    // It seems OSX 10.11 and higher needs to use defaults read -g AppleKeyboardUIMode
    if (parseInt(os.release().split('.')[0]) >= 15) {
        child_process.exec('defaults read -g AppleKeyboardUIMode', function (err, stdout, stderr) {
            if (err instanceof Error) {
                // return because we already have false set and error means text boxes and lists only
                return;
            }

            console.log("AppleKeyboardUIMode: ", stdout);

            //stdout can return the text error
            // The domain/default pair of (kCFPreferencesAnyApplication, AppleKeyboardUIMode) does not exist
            //This can be resolved by editing System Preferences. For older Mac systems select the Language and Text icon and add US English to the Languages list using the check box. For newer systems select the Language and Region icon and add English to the list, making it the primary language.

            if (parseInt(stdout) > 1) {
                FULL_KEYBOARD_ACCESS = true;
            }
        });
    } else {
        child_process.exec('defaults read NSGlobalDomain AppleKeyboardUIMode', function (err, stdout, stderr) {
            if (err instanceof Error) {
                // return because we already have false set and error means text boxes and lists only
                return;
            }

            console.log("AppleKeyboardUIMode: ", stdout);

            //stdout can return the text error
            // The domain/default pair of (kCFPreferencesAnyApplication, AppleKeyboardUIMode) does not exist
            //This can be resolved by editing System Preferences. For older Mac systems select the Language and Text icon and add US English to the Languages list using the check box. For newer systems select the Language and Region icon and add English to the list, making it the primary language.

            if (parseInt(stdout) > 1) {
                FULL_KEYBOARD_ACCESS = true;
            }
        });
    }

    // read the Messages.app sqlite db
    var db = new sqlite3.Database(file);

    // internally used variables
    var LAST_SEEN_ID = 0;
    var ENABLE_OTHER_SERVICES = false;
    var sending = false;

    function sendMessage(to, message, groupChat) {
        imessagemodule.sendMessage(to, message);
    }

    iMessageAdapter = (function (superClass) {
        extend(iMessageAdapter, superClass);

        function iMessageAdapter(robot) {
            this.robot = robot;
        }

        iMessageAdapter.prototype.checkMessageText = function (messageId) {
            var SQL = "SELECT DISTINCT message.ROWID, handle.id, message.text, message.is_from_me, message.date, message.date_delivered, message.date_read, chat.chat_identifier, chat.display_name FROM message LEFT OUTER JOIN chat ON chat.room_name = message.cache_roomnames LEFT OUTER JOIN handle ON handle.ROWID = message.handle_id WHERE message.service = 'iMessage' AND message.ROWID = " + messageId + " ORDER BY message.date DESC LIMIT 500";
            if (OLD_OSX) {
                SQL = "SELECT DISTINCT message.ROWID, handle.id, message.text, message.is_from_me, message.date, message.date_delivered, message.date_read FROM message LEFT OUTER JOIN chat LEFT OUTER JOIN handle ON handle.ROWID = message.handle_id WHERE message.service = 'iMessage' AND message.ROWID = " + messageId + " ORDER BY message.date DESC LIMIT 500";
            }
            var imAdapter = this;

            db.serialize(function () {
                var arr = [];
                db.all(SQL, function (err, rows) {
                    if (err) throw err;
                    // should only be one result since we are selecting by id but I am looping anyways
                    for (var i = 0; i < rows.length; i++) {
                        var row = rows[i];
                        console.log(row);
                        if (row.is_from_me || !row || !row.text) {
                            return;
                        }

                        var chatter;
                        var isGroupChat = false;
                        if (row.chat_identifier === null) {
                            chatter = row.id;
                        } else if (arr.indexOf(row.chat_identifier) < 0 && arr.indexOf(row.display_name + '-' + row.chat_identifier) < 0) {
                            if (row.chat_identifier.indexOf('chat') > -1) {
                                if (row.display_name && row.display_name !== "" && typeof(row.display_name) !== "undefined" || OLD_OSX) {
                                    chatter = row.display_name;
                                    isGroupChat = true;
                                }
                            } else {
                                if (row.chat_identifier && row.chat_identifier !== "" && typeof(row.chat_identifier) !== "undefined") {
                                    chatter = row.chat_identifier;
                                    isGroupChat = true;
                                }
                            }
                        }

                        var message = row.text;

                        console.log("message: ", message);
                        console.log("iMessage user: ", chatter);

                        imAdapter.receive(new TextMessage(chatter, message));

                        // could be used to clear applescript errors, parse message for "gtbot clear" or something like that
                        // applescript.execFile(__dirname + '/applescripts/send_return.AppleScript', [], function(err, result) {});
                    }
                });
            });
        };

        iMessageAdapter.prototype.send = function () {
            console.log("iMessageAdapter.send");
            var envelope, i, len, message, strings, user;
            envelope = arguments[0], strings = 2 <= arguments.length ? slice.call(arguments, 1) : [];
            user = envelope.user.id;

            console.log("envelope: ", envelope);
            console.log("envelope.user: ", envelope.user);
            console.log("envelope.user.id: ", user);

            for (i = 0, len = strings.length; i < len; i++) {
                sendMessage(envelope.user, strings[i]);
            }
        };

        iMessageAdapter.prototype.reply = function () {
            console.log("iMessageAdapter.reply");
            var envelope, strings;
            envelope = arguments[0], strings = 2 <= arguments.length ? slice.call(arguments, 1) : [];
            return this.send.apply(this, [envelope].concat(slice.call(strings)));
        };

        // Use setInterval to continually check iMessage for new messages every 3 seconds
        iMessageAdapter.prototype.run = function () {
            var imAdapter = this;

            // Set the Last Seen ID
            db.serialize(function () {
                db.all("SELECT MAX(ROWID) AS max FROM message", function (err, rows) {
                    if (rows) {
                        var max = rows[0].max;
                        if (max > LAST_SEEN_ID) {
                            LAST_SEEN_ID = max;
                            return;
                        }
                    }
                }.bind(this));
            }.bind(this));

            setInterval(function () {
                db.serialize(function () {
                    db.all("SELECT MAX(ROWID) AS max FROM message", function (err, rows) {
                        if (rows && !sending) {
                            var max = rows[0].max;
                            if (max > LAST_SEEN_ID) {
                                for (LAST_SEEN_ID; LAST_SEEN_ID <= max; LAST_SEEN_ID++) {
                                    imAdapter.checkMessageText(LAST_SEEN_ID);
                                }
                            }
                        }
                    }.bind(this));
                }.bind(this));
            }, 3000);

            return this.emit('connected');
        };

        return iMessageAdapter;

    })(Adapter);

    exports.use = function (robot) {
        return new iMessageAdapter(robot);
    };

}).call(this);

//# sourceMappingURL=imessage.js.map
